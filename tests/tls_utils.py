"""
This module expects to find certificate files, generated by the ``generate-certs.sh``
script, in the ``certs`` directory.
"""

import collections
import pathlib
import ssl
import sys

py_ver = sys.version_info
PY36 = py_ver.major == 3 and py_ver.minor == 6

CERTS_DIR = pathlib.Path(__file__).parent / "certs"
CERT_FILENAMES = ["ca.pem", "server.pem", "server.key", "client.pem", "client.key"]
CERT_FILES = [CERTS_DIR / f for f in CERT_FILENAMES]
CERTS_EXIST = all([p.exists() for p in CERT_FILES])


Certificates = collections.namedtuple(
    "Certificates",
    ["ca_cert", "server_cert", "server_key", "client_cert", "client_key"],
)


def get_certs() -> Certificates:
    return Certificates(*[p.as_posix() for p in CERT_FILES])


def create_ssl_server_context(cafile, certfile, keyfile) -> ssl.SSLContext:
    """ Create a :class:`ssl.SSLContext` that can be used by a Server.

    The server will use the certificate in *certfile* and private key in
    *keyfile* (both in PEM format) to authenticate itself.

    It requires clients to also authenticate themselves. Their certificates
    will be validated with the root CA certificate in *cafile*.

    It will use *TLS 1.2* with *ECDH+AESGCM* encryption. ECDH keys won't be
    reused in distinct SSL sessions. Compression is disabled.
    """
    # Setting the purpose to CLIENT_AUTH loads CA certificates for client
    # certificate verification on the server side.
    ctx = ssl.create_default_context(purpose=ssl.Purpose.CLIENT_AUTH)

    # Explicitly require client certificate verification
    ctx.verify_mode = ssl.CERT_REQUIRED

    ctx.set_ciphers("ECDH+AESGCM")
    ctx.load_cert_chain(certfile=certfile, keyfile=keyfile)

    if cafile:
        ctx.load_verify_locations(cafile=cafile)

    if PY36:
        ctx.options |= ssl.PROTOCOL_TLS | ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1
    else:
        ctx.minimum_version = ssl.TLSVersion.TLSv1_2
        ctx.maximum_version = ssl.TLSVersion.TLSv1_2

    return ctx


def create_ssl_client_context(cafile, certfile, keyfile):
    """ Create a :class:`ssl.SSLContext` that can be used by a Client.

    It uses the root CA certificate in *cafile* to validate the server's
    certificate. It will also check the server's hostname.

    The client will use the certificate in *certfile* and private key in
    *keyfile* (both in PEM format) to authenticate itself to the server.

    It will use *TLS 1.2* with *ECDH+AESGCM* encryption.

    """
    # Setting purpose to (the default) SERVER_AUTH sets verify_mode to
    # CERT_REQUIRED.
    ctx = ssl.create_default_context(purpose=ssl.Purpose.SERVER_AUTH)
    ctx.set_ciphers("ECDH+AESGCM")
    ctx.load_cert_chain(certfile=certfile, keyfile=keyfile)

    if cafile:
        ctx.load_verify_locations(cafile=cafile)

    ctx.check_hostname = True

    if PY36:
        ctx.options |= ssl.PROTOCOL_TLS | ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1
    else:
        ctx.minimum_version = ssl.TLSVersion.TLSv1_2
        ctx.maximum_version = ssl.TLSVersion.TLSv1_2

    return ctx
